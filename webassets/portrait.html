<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
	<link rel="stylesheet" href="styles.css">
	<title>The PMD Portrait Repository</title>
	
	<link rel="icon" 
      type="image/png" 
      href="favicon.png" />
	  
	<meta charset="utf-8"/>
	<meta name="description" content="The PMD Portrait Repository archives the great art of many artist making portraits based on Pokemon Mystery Dungeon"/>
	<meta name="author" content="u/TheDasK" />
	<meta name="robots" content="index,nofollow" />
	
	<script
		src="https://code.jquery.com/jquery-3.3.1.js"
		integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
		crossorigin="anonymous">
	</script>
	<script>
		$(function(){
			$("#header").load("header.html"); 
			$("#footer").load("footer.html"); 
		});
		
		function findGetParameter(parameterName) {
			let result = null, tmp = [];
			location.search.substr(1).split("&").forEach(function (item) {
				tmp = item.split("=");
				if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
			});
			return result;
		}
		
		function checkURLExists(url){ //gets what faces are avilable in a form
		
			var xhttp = new XMLHttpRequest();
			xhttp.onreadystatechange = function() {
				if (this.readyState == 4 && this.status != 200) {
					return false;
				}else{
					return true;
				}
			};
		}
		
		async function populateTable(id){
		
			let tracker = await fetch('https://raw.githubusercontent.com/PMDCollab/SpriteCollab/master/tracker.json').then(response => response.json());
			let container = document.getElementById("container");
			
			//get the entry
			let entry = tracker[id];
			if (!entry) entry = tracker["0000"];

			forms = subgroupUnfolding(entry); //look at how many forms it has
			
			for (i in forms) {
				
				let title = document.createElement("h2");
				
				title.innerHTML = forms[i].name
				title.setAttribute("class", "port-title");
				container.appendChild(title);
				
				let table = document.createElement("table");
				table.setAttribute("class", "port-table");
				
				makeTable(table, forms[i].path, true);
				table.setAttribute("class", "port-table");
				
				let row = table.insertRow(-1);							//credits
				let cell = row.insertCell(0);
				cell.innerHTML = forms[i].portrait_credit;
				cell.setAttribute("class", "port-expresion");
				cell.setAttribute("colspan", 5);
				
				container.appendChild(table);

				/*let donwload = document.createElement("div");
				donwload.innerHTML = "<p>Download!</p>"
				donwload.setAttribute("onclick", "createFilledImage(\""+forms[i].path+"\")");
				donwload.setAttribute("class", "Button");
				container.appendChild(donwload);*/
			}
				
		}
		
		function subgroupUnfolding(entry,path = "/"){ //I dont even know, dont read this, you dont deserve the migraine
		
			let subgroups = [];
			
			if (entry.name && entry.portrait_credit){
				let nentry = Object.assign({}, entry);
				nentry.path = path;
				delete nentry.subgroups;
				subgroups = subgroups.concat(nentry);
			}
			
			for (let i in entry.subgroups){
				ipath = path + i + "/";
				if (entry.subgroups[i].subgroups) (subgroups = subgroups.concat(subgroupUnfolding(entry.subgroups[i],ipath)));
			}
			
			return subgroups;
		}
		
		function imgMissing(img,index){
			
			img.src = "empty.png";
			missingExpresions[index] = true;
			if (index == 20) {
				let table = img.parentNode.parentNode.parentNode;
				table.deleteRow(15);
				table.deleteRow(14);
				table.deleteRow(13);
				table.deleteRow(12);
				table.deleteRow(11);
				table.deleteRow(10);
				table.deleteRow(9);
				table.deleteRow(8);
			}
		}
		
		async function loadCredits(creditsArray,creditsIndex){
		
			let xmlhttp = new XMLHttpRequest(creditsArray);
			
			/*xmlhttp.onreadystatechange = function() {
				switch (xmlhttp.readyState) {
					case 4:
						var status = xmlhttp.status;

						if (xmlhttp.response === '') {
							status = -1;
						}
						switch (status) {
							case 0:
							case 200:
								let lines =  xmlhttp.response.split('\n');
								for(var line = 0; line < lines.length; line++){
									creditsArray.push(lines[line].split('\t'));
								}
								break;
							default:
								document.write('Error: ' + errorText);
						}
						break;
					default:
						break;
				}
			}
			
			xmlhttp.open("GET", "https://raw.githubusercontent.com/PMDCollab/SpriteCollab/master/credit_names.txt", false);
			xmlhttp.send();*/
			
			var request = new XMLHttpRequest();
			request.open('GET', 'https://raw.githubusercontent.com/PMDCollab/SpriteCollab/master/credit_names.txt', false);  // `false` makes the request synchronous
			request.send(null);

			if (request.status === 200) {
				let lines =  request.responseText.split('\n');
				for(var line = 0; line < lines.length; line++){
					creditsArray.push(lines[line].split('\t'));
					creditsIndex.push(creditsArray[line][1]);
				}
			}
			
		}
		
		async function main(){
		
			await populateTable(id);
			
			let creditsArray = [];
			let creditsIndex = [];
			await loadCredits(creditsArray,creditsIndex);
			
			let cells = document.getElementsByClassName("port-expresion");
			
			for (cell in cells){
			
				cell = cells[cell];
				creditID = cell.innerHTML.replace("&lt;","<").replace("&gt;",">");
				
				let credits = creditsArray[creditsIndex.indexOf(creditID)];
				
				if (credits[0]){
					cell.innerHTML = 'Credit: <a href="http://'+credits[2]+'">' + credits[0] + '</a>';
				} else {
					cell.innerHTML = 'Credit: <a href="https://discordapp.com/users/'+credits[2].slice(3,-1)+'">' + credits[2].replace("!", "") + '</a>';
				}
			}
		}
		
		function makeTable(table,path,asymmetrical){
		
			let rowpic, rowtext, cell, npic = 0, rev = "", expname; //rev holds ^ when reversed + tells if its over 40, n pic is needed for the image creator
		
			for (nrow = 0; nrow < 16; nrow = nrow + 2){
			
				if (nrow == 8){
					if(!asymmetrical) break;
					rev = "^";
				}
				
				rowpic = table.insertRow(nrow);
				rowtext = table.insertRow(nrow + 1);
				
				for (col = 0; col < 5; col++){
				
					expname = expresionNames[rev == "" ? npic : npic - 20];
					
					cell = rowpic.insertCell(col);
					cell.innerHTML = '<img onerror="imgMissing(this,'+npic+')" src="https://raw.githubusercontent.com/PMDCollab/SpriteCollab/master/portrait/'+id+path+expname+rev+'.png\"></img>';
					cell = rowtext.insertCell(col);
					cell.innerHTML = expname;
					
					npic++;
				}
			}
		}
		
		function createFilledImage(path){
			/*
			let c=document.createElement("canvas");
			c.width = 200, c.height = 160;
			let ctx=c.getContext("2d");
			let col = 0, row = 0;
			let image;
			
			for (i = 0; i < 20; i++) {
			
				image = new Image();
				image.onload = function() {
					ctx.drawImage(image, 40 * col, 40 * row)
				};
				image.src = "portrait/"+id+path+"Normal.png";
				
				col++;
				if (col == 5){
					col = 0;
					row++;
				}
			}

			container.appendChild(c);
			var link = document.createElement('a');
			link.download = 'filename.png';
			link.href = c.toDataURL()
			link.click();*/
		}

		let missingExpresions = new Array(40).fill(false);
		let expresionNames = ["Normal","Happy","Pain","Angry","Worried","Sad","Crying","Shouting","Teary-Eyed","Determined","Joyous","Inspired","Surprised","Dizzy","Special0","Special1","Sigh","Stunned","Special2","Special3"]

		let id = findGetParameter("id");
		if (!(id)) id = false;

		main();
	</script>
</head>
<body>
	<div id="header"></div>

	<div id="container">
	</div>

	<div id="footer"></div>
</body>
</html>